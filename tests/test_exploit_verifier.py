import unittest
from unittest.mock import MagicMock, patch
import sys
import os

# Adjust path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from web_ui.parsers.exploit_verifier import ExploitVerifier
from web_ui.models import VulnerabilityModel

class TestExploitVerifier(unittest.TestCase):

    def setUp(self):
        self.mock_client = MagicMock()
        self.verifier = ExploitVerifier(self.mock_client)

    def test_generate_verification_script(self):
        vuln = VulnerabilityModel(
            title="SQL Injection",
            severity="High",
            affected_url="http://test.com/id=1"
        )
        
        # Mock Gemini response
        mock_response = MagicMock()
        mock_response.text = "```python\\nimport requests\\nprint('VULNERABLE')\\n```"
        self.mock_client.models.generate_content.return_value = mock_response
        
        script = self.verifier.generate_verification_script(vuln)
        
        self.assertIn("import requests", script)
        self.assertIn("print('VULNERABLE')", script)
        self.mock_client.models.generate_content.assert_called_once()

    def test_verify_vuln_safe_execution(self):
        # We need to test that the script execution is safe (e.g. timeout, no os.system)
        # For now, we'll just check if it calls the execution wrapper
        pass

if __name__ == '__main__':
    unittest.main()
