"""
Intelligent Exploit Verification System
Analyzes tool output to determine if exploitation was successful
"""

import re
from typing import Dict, List

class ExploitVerifier:
    """Verifies if an exploitation attempt was successful."""
    
    # Success indicators for different exploit types
    SUCCESS_PATTERNS = {
        'sqlmap': [
            r"parameter.*is vulnerable",
            r"os-shell>",
            r"sql-shell>",
            r"current user.*root|admin|sa|postgres",
            r"file-write.*successful"
        ],
        'commix': [
            r"exploitation appears to be successful",
            r"pseudo-terminal shell",
            r"command injection vulnerability"
        ],
        'metasploit': [
            r"session \d+ opened",
            r"meterpreter >",
            r"exploit completed successfully"
        ],
        'hydra': [
            r"\[.*\]\[.*\] host:.*login:.*password:",
            r"valid password found"
        ],
        'webshell': [
            r"shell uploaded successfully",
            r"backdoor deployed"
        ],
        'default': [
            r"success",
            r"exploit.*successful",
            r"shell",
            r"root@",
            r"admin@",
            r"uid=0"  # Root user
        ]
    }
    
    # Failure indicators
    FAILURE_PATTERNS = [
        r"exploitation failed",
        r"target.*not vulnerable",
        r"connection.*refused",
        r"timeout",
        r"error",
        r"denied",
        r"forbidden"
    ]
    
    @classmethod
    def verify_exploitation(cls, tool_name: str, output: str) -> Dict[str, any]:
        """
        Verifies if exploitation was successful.
        
        Returns:
            {
                'success': bool,
                'confidence': float (0.0-1.0),
                'evidence': List[str],
                'session_info': Dict or None
            }
        """
        result = {
            'success': False,
            'confidence': 0.0,
            'evidence': [],
            'session_info': None
        }
        
        output_lower = output.lower()
        
        # Get relevant patterns for this tool
        tool_key = None
        for key in cls.SUCCESS_PATTERNS.keys():
            if key in tool_name.lower():
                tool_key = key
                break
        
        patterns = cls.SUCCESS_PATTERNS.get(tool_key, cls.SUCCESS_PATTERNS['default'])
        
        # Check for success indicators
        success_count = 0
        for pattern in patterns:
            matches = re.findall(pattern, output, re.IGNORECASE | re.MULTILINE)
            if matches:
                success_count += 1
                result['evidence'].append(f"Found: {matches[0][:100]}")
        
        # Check for failure indicators
        failure_count = 0
        for pattern in cls.FAILURE_PATTERNS:
            if re.search(pattern, output, re.IGNORECASE):
                failure_count += 1
        
        # Calculate confidence
        if success_count > 0 and failure_count == 0:
            result['success'] = True
            result['confidence'] = min(1.0, success_count * 0.3)
        elif success_count > failure_count:
            result['success'] = True
            result['confidence'] = min(1.0, (success_count - failure_count) * 0.2)
        
        # Extract session information if available
        result['session_info'] = cls._extract_session_info(output)
        
        return result
    
    @classmethod
    def _extract_session_info(cls, output: str) -> Dict or None:
        """Extract session details from exploit output."""
        session_info = {}
        
        # Metasploit session
        msf_match = re.search(r"session (\d+) opened.*?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", 
                             output, re.IGNORECASE)
        if msf_match:
            session_info['session_id'] = msf_match.group(1)
            session_info['target_ip'] = msf_match.group(2)
            session_info['type'] = 'meterpreter' if 'meterpreter' in output.lower() else 'shell'
        
        # SQLMap shell
        if 'os-shell>' in output or 'sql-shell>' in output:
            session_info['type'] = 'db_shell'
            session_info['capabilities'] = ['command_exec', 'db_query']
        
        # Web shell
        if 'shell uploaded' in output.lower():
            url_match = re.search(r'http[s]?://[^\s]+', output)
            if url_match:
                session_info['type'] = 'web_shell'
                session_info['url'] = url_match.group(0)
        
        return session_info if session_info else None
    
    @classmethod
    def suggest_next_steps(cls, tool_name: str, verification: Dict) -> List[str]:
        """Suggest next steps based on exploitation results."""
        suggestions = []
        
        if not verification['success']:
            suggestions.append("Exploitation failed. Try alternative exploit or tool.")
            suggestions.append("Verify target is vulnerable with additional reconnaissance.")
            return suggestions
        
        # Successful exploitation - suggest post-exploitation
        if verification['session_info']:
            session_type = verification['session_info'].get('type')
            
            if session_type == 'meterpreter':
                suggestions.append("Run 'sysinfo' to gather system information")
                suggestions.append("Check privileges with 'getuid'")
                suggestions.append("Attempt privilege escalation with 'getsystem'")
                suggestions.append("Dump credentials with 'hashdump'")
                suggestions.append("Setup persistence with 'run persistence'")
            
            elif session_type == 'db_shell':
                suggestions.append("Enumerate database users and privileges")
                suggestions.append("Attempt file read/write operations")
                suggestions.append("Try to escalate to OS command execution")
            
            elif session_type == 'shell':
                suggestions.append("Enumerate system: 'uname -a', 'whoami', 'id'")
                suggestions.append("Find SUID binaries: 'find / -perm -4000 2>/dev/null'")
                suggestions.append("Check sudo permissions: 'sudo -l'")
                suggestions.append("Setup persistence via crontab or rc.local")
        else:
            suggestions.append("Verify session establishment with 'check_sessions'")
            suggestions.append("Monitor for reverse shell connections")
        
        return suggestions
