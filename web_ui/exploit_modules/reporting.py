"""
Automated Reporting Module
Generate professional penetration testing reports
"""

import json
import datetime
from typing import Dict, List, Optional

class ReportingModule:
    """
    Automated report generation for penetration testing results.
    """
    
    def __init__(self):
        self.report_data = {
            'metadata': {},
            'executive_summary': {},
            'findings': [],
            'timeline': [],
            'sessions': [],
            'compromised_hosts': [],
            'exfiltrated_data': [],
            'credentials': []
        }
    
    def generate_full_report(self, vuln_store, session_store, callback=None) -> Dict:
        """
        Generate complete penetration test report.
        
        Args:
            vuln_store: VulnStore instance
            session_store: SessionStore instance
            callback: Optional callback
        
        Returns:
            Complete report data structure
        """
        if callback:
            callback({'message': 'ðŸ“Š Generating comprehensive penetration test report...'})
        
        # 1. Metadata
        self.report_data['metadata'] = self._generate_metadata()
        
        # 2. Executive Summary
        if callback:
            callback({'message': '  ðŸ“ Creating executive summary...'})
        
        self.report_data['executive_summary'] = self._generate_executive_summary(
            vuln_store, session_store
        )
        
        # 3. Technical Findings
        if callback:
            callback({'message': '  ðŸ” Compiling technical findings...'})
        
        self.report_data['findings'] = self._generate_findings(vuln_store)
        
        # 4. Timeline
        if callback:
            callback({'message': '  â±ï¸ Building attack timeline...'})
        
        self.report_data['timeline'] = self._generate_timeline()
        
        # 5. Compromised Systems
        if callback:
            callback({'message': '  ðŸŽ¯ Documenting compromised systems...'})
        
        self.report_data['sessions'] = self._generate_session_summary(session_store)
        
        # 6. Data Exfiltration Summary
        from data_exfiltration import data_exfiltration
        self.report_data['exfiltrated_data'] = data_exfiltration.get_exfiltration_summary()
        
        # 7. Network Map
        from lateral_movement import lateral_movement
        self.report_data['network_map'] = lateral_movement.get_network_map()
        
        if callback:
            callback({'message': 'âœ… Report generation complete!'})
        
        return self.report_data
    
    def generate_executive_summary(self, vuln_store, session_store, callback=None) -> str:
        """
        Generate executive-level summary for management.
        
        Returns:
            Executive summary as markdown string
        """
        summary = self._generate_executive_summary(vuln_store, session_store)
        
        report = f"""# Executive Summary

## Assessment Overview
- **Target**: {summary['target']}
- **Assessment Date**: {summary['date']}
- **Duration**: {summary['duration']}
- **Scope**: {summary['scope']}

## Key Findings
{summary['key_findings']}

## Risk Assessment
- **Overall Risk Level**: {summary['risk_level']}
- **Critical Vulnerabilities**: {summary['critical_count']}
- **High Vulnerabilities**: {summary['high_count']}
- **Systems Compromised**: {summary['compromised_systems']}

## Business Impact
{summary['business_impact']}

## Recommendations
{summary['recommendations']}
"""
        
        return report
    
    def generate_technical_report(self, vuln_store, callback=None) -> str:
        """
        Generate detailed technical findings report.
        
        Returns:
            Technical report as markdown string
        """
        findings = self._generate_findings(vuln_store)
        
        report = "# Technical Findings\n\n"
        
        # Group by severity
        severity_order = ['critical', 'high', 'medium', 'low', 'info']
        
        for severity in severity_order:
            severity_findings = [f for f in findings if f['severity'].lower() == severity]
            
            if severity_findings:
                report += f"\n## {severity.upper()} Severity Findings ({len(severity_findings)})\n\n"
                
                for i, finding in enumerate(severity_findings, 1):
                    report += f"### {i}. {finding['title']}\n\n"
                    report += f"**Severity**: {finding['severity'].upper()}\n\n"
                    report += f"**CVSS Score**: {finding.get('cvss_score', 'N/A')}\n\n"
                    report += f"**Affected URL/Host**: {finding['url']}\n\n"
                    
                    if finding.get('cve'):
                        report += f"**CVE**: {finding['cve']}\n\n"
                    
                    report += f"**Description**:\n{finding['details']}\n\n"
                    
                    if finding.get('exploit'):
                        report += f"**Exploitation**:\n```\n{finding['exploit']}\n```\n\n"
                    
                    report += f"**Recommendation**: {finding.get('recommendation', 'Apply vendor patches and security updates.')}\n\n"
                    report += "---\n\n"
        
        return report
    
    def generate_attack_timeline(self, callback=None) -> str:
        """
        Generate visual attack timeline.
        
        Returns:
            Timeline as markdown string
        """
        timeline = self._generate_timeline()
        
        report = "# Attack Timeline\n\n"
        report += "This timeline shows the chronological sequence of the penetration test.\n\n"
        
        for event in timeline:
            timestamp = event['timestamp']
            action = event['action']
            details = event['details']
            
            report += f"**{timestamp}** - {action}\n"
            report += f"  - {details}\n\n"
        
        return report
    
    def export_to_json(self, output_file: str = 'pentest_report.json', callback=None) -> str:
        """
        Export report data to JSON format.
        
        Args:
            output_file: Output file path
            callback: Optional callback
        
        Returns:
            Path to exported file
        """
        if callback:
            callback({'message': f'ðŸ“„ Exporting report to JSON: {output_file}...'})
        
        with open(output_file, 'w') as f:
            json.dump(self.report_data, f, indent=2)
        
        if callback:
            callback({'message': f'âœ… Report exported to {output_file}'})
        
        return output_file
    
    def export_to_markdown(self, output_file: str = 'pentest_report.md', vuln_store=None, session_store=None, callback=None) -> str:
        """
        Export complete report to Markdown format.
        
        Args:
            output_file: Output file path
            vuln_store: VulnStore instance
            session_store: SessionStore instance
            callback: Optional callback
        
        Returns:
            Path to exported file
        """
        if callback:
            callback({'message': f'ðŸ“„ Generating Markdown report: {output_file}...'})
        
        # Generate full report
        if vuln_store and session_store:
            self.generate_full_report(vuln_store, session_store, callback)
        
        # Build markdown document
        markdown = "# Penetration Test Report\n\n"
        
        # Metadata
        markdown += f"**Generated**: {self.report_data['metadata']['timestamp']}\n\n"
        markdown += "---\n\n"
        
        # Executive Summary
        markdown += self.generate_executive_summary(vuln_store, session_store)
        markdown += "\n---\n\n"
        
        # Technical Findings
        markdown += self.generate_technical_report(vuln_store)
        markdown += "\n---\n\n"
        
        # Attack Timeline
        markdown += self.generate_attack_timeline()
        markdown += "\n---\n\n"
        
        # Sessions
        markdown += "# Compromised Systems\n\n"
        for session in self.report_data['sessions']:
            markdown += f"- **{session['target_ip']}** ({session['session_type']}) - Status: {session['status']}\n"
        
        markdown += "\n---\n\n"
        
        # Network Map
        markdown += "# Network Topology\n\n"
        markdown += f"**Total Compromised**: {self.report_data['network_map'].get('total_compromised', 0)}\n\n"
        markdown += f"**Pivot Routes**: {len(self.report_data['network_map'].get('pivot_routes', []))}\n\n"
        
        # Write to file
        with open(output_file, 'w') as f:
            f.write(markdown)
        
        if callback:
            callback({'message': f'âœ… Markdown report saved to {output_file}'})
        
        return output_file
    
    def _generate_metadata(self) -> Dict:
        """Generate report metadata."""
        return {
            'timestamp': datetime.datetime.now().isoformat(),
            'tool': 'HackingTool AI Agent v3.0',
            'report_version': '1.0'
        }
    
    def _generate_executive_summary(self, vuln_store, session_store) -> Dict:
        """Generate executive summary data."""
        # Get vulnerability statistics
        all_vulns = []
        if vuln_store:
            # Collect all vulnerabilities from vuln_store
            # Collect from vuln_store
            all_vulns = []
            
            if vuln_store:
                # Get all vulnerabilities from the store
                try:
                    for target, data in vuln_store.data.items():
                        all_vulns.extend(data.get('vulns', []))
                except:
                    pass
        
        critical_count = len([v for v in all_vulns if v.get('severity') == 'critical'])
        high_count = len([v for v in all_vulns if v.get('severity') == 'high'])
        medium_count = len([v for v in all_vulns if v.get('severity') == 'medium'])
        
        # Get session statistics
        compromised_systems = 0
        if session_store:
            compromised_systems = session_store.get_summary().get('total_sessions', 0)
        
        # Determine overall risk level
        if critical_count > 0:
            risk_level = "CRITICAL"
        elif high_count > 0:
            risk_level = "HIGH"
        elif medium_count > 0:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        return {
            'target': 'Target Network',
            'date': datetime.datetime.now().strftime('%Y-%m-%d'),
            'duration': 'Automated',
            'scope': 'Full network assessment',
            'key_findings': f"""
- Identified {len(all_vulns)} total vulnerabilities
- Successfully compromised {compromised_systems} systems
- Achieved lateral movement across network
- Extracted sensitive data and credentials
""",
            'risk_level': risk_level,
            'critical_count': critical_count,
            'high_count': high_count,
            'medium_count': medium_count,
            'compromised_systems': compromised_systems,
            'business_impact': """
The assessment revealed significant security vulnerabilities that pose a high risk to the organization.
Successful exploitation allowed for complete network compromise, data exfiltration, and persistent access.
Immediate remediation is recommended.
""",
            'recommendations': """
1. Patch all critical vulnerabilities immediately
2. Implement network segmentation
3. Enforce strong password policies
4. Deploy multi-factor authentication
5. Improve logging and monitoring
6. Conduct security awareness training
"""
        }
    
    def _generate_findings(self, vuln_store) -> List[Dict]:
        """Generate list of findings with details - REAL IMPLEMENTATION."""
        findings = []
        
        if not vuln_store:
            return findings
        
        try:
            # Get all targets from vuln store
            from vuln_store import get_vuln_store
            store = get_vuln_store()
            
            # Iterate through all stored vulnerabilities
            all_data = store.data
            
            for target, vuln_data in all_data.items():
                # Extract vulnerabilities
                for vuln in vuln_data.get('vulns', []):
                    finding = {
                        'title': vuln.get('title', 'Unknown Vulnerability'),
                        'severity': vuln.get('severity', 'medium'),
                        'url': vuln.get('url', target),
                        'details': vuln.get('details', ''),
                        'cve': vuln.get('cve'),
                        'cvss_score': vuln.get('cvss_score', 'N/A'),
                        'exploit': vuln.get('exploit', ''),
                        'recommendation': vuln.get('recommendation', 'Apply security patches and follow best practices.')
                    }
                    findings.append(finding)
        except Exception as e:
            logging.error(f"Error generating findings: {e}")
        
        return findings
    
    def _generate_timeline(self) -> List[Dict]:
        """Generate attack timeline events - REAL IMPLEMENTATION."""
        timeline = []
        
        try:
            # Check if agent has timeline tracking
            from agent_manager import agent_manager
            
            if hasattr(agent_manager, 'timeline') and agent_manager.timeline:
                timeline = agent_manager.timeline
            else:
                # Fallback: Generate timeline from session store
                from session_store import get_session_store
                store = get_session_store()
                
                for session in store.list_sessions():
                    timeline.append({
                        'timestamp': session.created_at.isoformat() if hasattr(session, 'created_at') else datetime.datetime.now().isoformat(),
                        'action': f'Session Established ({session.session_type.value})',
                        'details': f'Compromised {session.target_ip} via {session.source_tool}'
                    })
                    
                    if session.status.value == 'active':
                        timeline.append({
                            'timestamp': datetime.datetime.now().isoformat(),
                            'action': 'Active Session',
                            'details': f'Maintaining access to {session.target_ip}'
                        })
        except Exception as e:
            logging.error(f"Error generating timeline: {e}")
            
            # Fallback timeline if everything fails
            timeline = [
                {
                    'timestamp': datetime.datetime.now().isoformat(),
                    'action': 'Assessment Started',
                    'details': 'Automated penetration test initiated'
                }
            ]
        
        return timeline
    
    def _generate_session_summary(self, session_store) -> List[Dict]:
        """Generate summary of all sessions."""
        sessions = []
        
        if session_store:
            for session in session_store.list_sessions():
                sessions.append({
                    'session_id': session.session_id,
                    'target_ip': session.target_ip,
                    'session_type': session.session_type.value,
                    'status': session.status.value,
                    'source_tool': session.source_tool
                })
        
        return sessions

# Singleton instance
reporting_module = ReportingModule()
